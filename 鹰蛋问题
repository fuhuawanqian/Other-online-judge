鹰蛋问题:
注意点：
无法保证能得出脆弱度的方案根本就是错误的,更谈不上最优不最优
所以方案应该首先能够得出最弱度，然后在这个基础上考虑最优解
1.如果有无数个鸡蛋，那当然就是二分了
2.一种方案:
把楼层分为x等分，用第一鹰蛋从下往上依次试探一个范围，如果第一个鹰蛋破了，则用另一鹰蛋穷举。
假如将100层楼分为20等分,则用第一个鹰蛋分别在第5层,第10层,第15层...依次试探,假如在35层鹰蛋破碎,
则用另一个鹰蛋从31层到34层依次试探,则可以求出破蛋的临界点.
上面的方法的最坏情况是鹰蛋的临界点在N-1层（N代表总楼层数）,也就是倒数第二层.因为这时候第一个蛋把所有的等分楼层都尝试了一遍,
而且第二个蛋也要把一个等分内部的楼层全部尝试一遍.
假设把总楼层分成了X等份，每个等分内部有N/X个楼层.
在最坏情况下，第一个蛋需要试探X次,第二蛋则要试探N/X-1次（即在每个等份内做穷举）,所以最坏情况需要的总次数为X+(N/X)-1
要获取最坏情况的最小值,需要对总次数X+(N/X)-1求导数,并取0值,即:
(X + (N/X) -1)'(求导)
=1- (N/X2) 
=0
求解，可以得到X = sqrt(N)。
在楼层=100的情况下,可以求出使总次数最小的X=10,也就是说如果采用等份的办法,在楼层总数是100时,10等份是最优情况.
3.  -------------\
    |           | \   
    |           |  m-i层
    |           | /   
    |-----------|<-----i
    |           |\
    |           | /i-1层
    |-----------|/
    
动态规划的状态转移方程如下：
F(m,n)= MIN{ MAX{ F(i-1, n-1) + 1, F(m-i, n)+1}};(0 < i < m)

int dp[maxn][maxn];
int floor_egg_problem(int floor,int egg){
    if(dp[floor][egg]!=0) return arr[floor][egg];
    if(egg<=1) return floor;
    if(!floor) return 0;
    if(floor==1) return 1;
    int ans=inf;
    for(int i=1;i<=floor;i++){
        int u=floor_egg_problem(i-1,egg-1)+1;
        int v=floor_egg_problem(floor-i,egg)+1;
        int z=max(u,v);
        ans=min(ans,z);
    }
    arr[floor][egg]=ans;
    return ans;
}
